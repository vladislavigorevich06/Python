Постановка задачи
Числовое кольцо. В кольце записаны N чисел, составляющих по часовой стрелке 3 числа: два слагаемых и сумму. Требуется написать программу, которая по строке чисел, считая ее кольцом, находит какое-нибудь 
решение в виде A+B=C. Все цифры числа должны входить в числа только один раз и в порядке следования в кольце. Цифр в кольце не более 1000. Формат входных данных: Входной файл содержит 1 строку, в которой без 
пробелов перечислены цифры кольца. Формат выходных данных: В выходной файл выводится тождество в виде += без пробелов внутри или слово «No», если решения не существует.











Алгоритм решения 
Для решения поставленной задачи был реализован следующий алгоритм:
1. Представление данных:
•	Входная строка цифр (от 3 до 1000 символов) интерпретируется как кольцо — структура, в которой последний элемент логически соединён с первым.
•	Кольцо реализовано с использованием односвязного кольцевого списка, где каждый элемент хранит одну цифру и ссылку на следующий.

2. Структуры данных:
Node (узел кольца):
digit: Символ, представляющий цифру (от '0' до '9').
next: Указатель на следующий узел в кольце.
Ring (кольцо):
head: Указатель на первый узел кольца.
length: Длина кольца (количество цифр).
_build_ring(): Метод построения кольцевого списка из строки цифр.

3. Основные методы и классы:
Класс Ring:
__init__(digits): Проверяет корректность строки, вызывает построение кольца.
get_substring(start_index, length): Возвращает подстроку заданной длины, начиная с позиции start_index, переходя через границу кольца, если нужно.
Класс Solver:
__init__(digits): Инициализирует кольцо из входной строки.
solve(): Основной метод. Перебирает все возможные позиции и длины разбиений кольца на три числа A, B и C, и проверяет условие A + B = C.
_try_partition(start, len_a, len_b, len_c): Разбить кольцо на три части, преобразовать их в числа и проверить правильность выражения.

4. Алгоритм solve() в классе Solver:
Перебираются все возможные позиции start в кольце от 0 до length - 1.
Для каждой позиции подбираются длины чисел A и B от 1 до length - 2, так как хотя бы одно место должно остаться для C.
Длина C вычисляется как length - len(A) - len(B).
При каждом разбиении вызывается _try_partition(), который:
Извлекает подстроки A, B и C с помощью метода get_substring.
Проверяет, что числа корректны (не начинаются с нуля, если длина > 1).
Переводит строки в числа (собственный метод string_to_int).
Проверяет условие A + B == C. Если оно выполнено — возвращает результат.
Если ни одно выражение не найдено — возвращается "No".

5. Выбор структур данных:
Кольцевой односвязный список выбран, так как:
Он естественным образом моделирует кольцевую  входных данных.
Удаление и обход кольца возможны без лишнего копирования данных.
Метод get_substring() позволяет обращаться к любой подстроке длины n начиная с позиции start, с учётом перехода через конец.
Строки и символы обрабатываются без использования стандартных функций Python (len, int, str.split) — вся логика реализована вручную:
string_length(s): определяет длину строки вручную.
string_to_int(s): перевод строки в число по собственной логике.
is_valid_number(s): проверяет отсутствие ведущих нулей.

6. Обоснование выбора структур и типов данных:
Целые числа и строки:
Цифры представлены символами от '0' до '9'. Такой подход позволяет легко проверять валидность ввода и реализовать собственное преобразование в число.
Односвязный кольцевой список:
Позволяет моделировать бесконечный сдвиг по кольцу без дублирования данных.
Простая структура узлов (Node) с минимальными затратами по памяти.
Функции проверки (is_digit, is_valid_number):
Упрощают валидацию данных, делают код модульным и читаемым.

7. Использование переменных и вспомогательных флагов:
Флаги типа None / result:
Метод solve() возвращает выражение в формате A+B=C, если оно найдено, иначе — строку "No".
Это позволяет интерфейсу программы мгновенно выводить понятный результат пользователю.
Переменные итерации:
Индексы start, len_a, len_b, len_c — ключевые переменные для перебора всех возможных разбиений строки.

8. Оценка сложности алгоритма:
Сложность составляет O(n³), в среднем программа работает значительно быстрее, так как завершает перебор сразу после нахождения первого корректного выражения.














Тестирование
 
 #Программа для поиска выражения вида A+B=C в числовом кольце
#Выберите способ ввода данных:
#1 - Ввести вручную
#2 - Прочитать из файла input.txt
#> 2
#Строка из файла: 01902021
#Результат: 190+20=210


#Программа для поиска выражения вида A+B=C в числовом кольце
#Выберите способ ввода данных:
#1 - Ввести вручную
#2 - Прочитать из файла input.txt
#> 2
#Строка из файла: 121224
#Результат: 12+12=24


#Программа для поиска выражения вида A+B=C в числовом кольце
#Выберите способ ввода данных:
#1 - Ввести вручную
#2 - Прочитать из файла input.txt
#> 2
#Строка из файла: 1111111
#Результат: No


#Программа для поиска выражения вида A+B=C в числовом кольце
#Выберите способ ввода данных:
#1 - Ввести вручную
#2 - Прочитать из файла input.txt
#> 2
#Строка из файла:
#Ошибка: строка слишком короткая


#Программа для поиска выражения вида A+B=C в числовом кольце
#Выберите способ ввода данных:
#1 - Ввести вручную
#2 - Прочитать из файла input.txt
#> 2
#Строка из файла: bbb
#Ошибка: строка должна содержать только цифры


#Программа для поиска выражения вида A+B=C в числовом кольце
#Выберите способ ввода данных:
#1 - Ввести вручную
#2 - Прочитать из файла input.txt
#> 1
#Введите строку, содержащую только цифры (от 3 до 1000):
#> 1
#Ошибка: строка слишком короткая
 
 
 
 








Код программы
MAX_LENGTH = 1000  #максимальная длина входной строки

#класс узла кольца
class Node:
    def __init__(self, digit):
        if not is_digit(digit):  #если символ не цифра
            raise ValueError("Узел должен содержать только одну цифру")
        self.digit = digit  #цифра узла
        self.next = None  #ссылка на следующий узел

#класс кольцевого списка
class Ring:
    def __init__(self, digits):
        self.length = string_length(digits)  #длина строки
        if self.length < 3:
            raise ValueError("Минимальная длина кольца — 3 символа")
        if self.length > MAX_LENGTH:
            raise ValueError("Длина кольца не должна превышать 1000 символов")
        self.head = self._build_ring(digits)  #построение кольца

    def _build_ring(self, digits):
        nodes = []  #список узлов
        i = 0
        while i < string_length(digits):  #создание узлов
            ch = digits[i]
            if not is_digit(ch):  #проверка цифры
                raise ValueError("Ввод должен содержать только цифры")
            nodes.append(Node(ch))  #добавление узла
            i += 1

        i = 0
        while i < string_length(digits):  #связывание узлов
            next_index = i + 1
            if next_index == string_length(digits):  #замыкание в кольцо
                next_index = 0
            nodes[i].next = nodes[next_index]  #ссылка на следующий
            i += 1

        return nodes[0]  #возвращаем голову

    def get_substring(self, start_index, length):
        if length <= 0 or length >= self.length:  #некорректная длина
            return ""

        current = self.head  #начинаем с головы
        i = 0
        while i < (start_index % self.length):  #сдвигаем старт
            current = current.next
            i += 1

        result = ""  #накапливаем подстроку
        j = 0
        while j < length:  #берем символы
            result += current.digit
            current = current.next
            j += 1

        return result  #возвращаем строку

#класс который решает
class Solver:
    def __init__(self, digits):
        self.ring = Ring(digits)  #создаем кольцо
        self.length = self.ring.length  #длина кольца

    def _try_partition(self, start, len_a, len_b, len_c):
        a = self.ring.get_substring(start, len_a)  #слагаемое a
        b = self.ring.get_substring(start + len_a, len_b)  #слагаемое b
        c = self.ring.get_substring(start + len_a + len_b, len_c)  #сумма c

        if not (is_valid_number(a) and is_valid_number(b) and is_valid_number(c)):
            return None  #если есть невалидное число

        if string_to_int(a) + string_to_int(b) == string_to_int(c):  #проверка суммы
            return a + "+" + b + "=" + c  #возвращаем выражение

        return None  #если выражение неверное

    def solve(self):
        start = 0
        while start < self.length:  #по всем позициям
            len_a = 1
            while len_a < self.length - 1:  #по длинам a
                len_b = 1
                while len_b < self.length - len_a:  #по длинам b
                    len_c = self.length - len_a - len_b  #вычисляем длину c
                    if len_c > 0:
                        result = self._try_partition(start, len_a, len_b, len_c)
                        if result:  #если найдено
                            return result
                    len_b += 1
                len_a += 1
            start += 1
        return "No"  #если не найдено подходящее выражение

def is_digit(char):
    return '0' <= char and char <= '9'  #проверка что символ — цифра

def string_length(s):
    count = 0  #счетчик
    for ch in s:  #проход по строке
        count += 1
    return count  #возвращаем длину

def string_to_int(s):
    DIGIT_TO_INT = {  #таблица перевода
        '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,
        '5': 5, '6': 6, '7': 7, '8': 8, '9': 9
    }
    value = 0  #накопленное значение
    i = 0
    while i < string_length(s):  #по всем символам
        ch = s[i]
        value = value * 10 + DIGIT_TO_INT[ch]  #перевод в число
        i += 1
    return value  #возвращаем число

def is_valid_number(s):
    return not (s[0] == '0' and string_length(s) > 1)  #проверка ведущего нуля

def run_interface():
    print("Программа для поиска выражения вида A+B=C в числовом кольце")
    print("Выберите способ ввода данных:")
    print("1 - Ввести вручную")
    print("2 - Прочитать из файла input.txt")

    choice = input("> ")

    if choice == "1":
        print("Введите строку, содержащую только цифры (от 3 до 1000):")
        user_input = input("> ")
    elif choice == "2":
        try:
            with open("input.txt", "r", encoding="utf-8") as f:
                user_input = f.read().strip()
            print("Строка из файла:", user_input)
        except FileNotFoundError:
            print("Файл input.txt не найден")
            return
    else:
        print("Некорректный выбор")
        return

    length = string_length(user_input)  #длина ввода
    if length < 3:
        print("Ошибка: строка слишком короткая")
        return
    if length > MAX_LENGTH:
        print("Ошибка: строка слишком длинная")
        return

    i = 0
    while i < length:
        ch = user_input[i]
        if not is_digit(ch):  #если не цифра
            print("Ошибка: строка должна содержать только цифры")
            return
        i += 1

    try:
        solver = Solver(user_input)  #создаем решатель
        result = solver.solve()  #ищем выражение
        print("Результат:", result)  #вывод результата
        with open("output.txt", "w", encoding="utf-8") as f:
            f.write(result)
    except ValueError as ve:
        print("Ошибка:", ve)
    except Exception as e:
        print("Произошла непредвиденная ошибка:", e)

if __name__ == "__main__":
    run_interface()

